---
title: 데이터 형식
date: 2024-10-5 09:25:00 +09:00
categories: [데이터 타입]
tags:
  [
    공부,
    C#,
    값 형식,
    값 타입,
    참조 형식,
    참조 타입,
    .
  ]
---

## 개요
1. 값, 참조 형식 (메모리 메커니즘)
    - 참조 형식이 가비지 컬렉터로 관리되는 이유?
2. 값, 참조 형식을 구분하라
    - more effective item
3. 불변 객체의 장점
4. [심화] 동일성 개념
    - 동일성 비교에 4가지 메서드가 필요한 이유?
    - 값 타입에서 Equals()를 재정의하자
    - 해쉬 알고리즘 GetHashCode()

# 1. 값, 참조 형식 (메모리 메커니즘)
### 개요
- 모든 타입을 값 타입으로 정의한 C++, 모든 타입이 참조인 JAVA와 다르게 C# 은 값, 참조 두 가지 데이터 형식을 사용한다.
> 값과 참조 타입은 동작 방식이 다른데 왜 굳이 두 개의 형식으로 분류한 걸까? 
- 여기서는 두 가지 타입의 특성과 장단점을 이해해본다.

### 값 타입과 참조 타입의 차이점
- 값 타입과 참조 타입의 가장 큰 차이점은 바로 할당이다.
#### 예제1
```cs
// 구조체(값 타입) 가정
CourseInfo courseInfo = new CourseInfo("Science1", "B1", new Credit(2));
// 클래스(참조 타입) 가정
Student student = new Student("Pete", new Credit(15), new PhoneNumber(82, "01024179973"));

var copyCourseInfo = courseInfo;
var copyStudent = student;

copyCourseInfo.ClassRoom = "C1";
// 해당 과목만큼 학생의 이수 학점(Credit)이 줄어든다.
copyStudent.RegisterCourse(courseInfo);

Console.WriteLine(courseInfo.ClassRoom);
Console.WriteLine(student.Credit);
```
- 값과 참조 타입은 위 결과에서 상반된 결과를 보인다. 이유가 뭘까?

> 값 타입은 데이터 용도로 사용한다. 할당 시 값 자체가 복사(깊은 복사)되어 원본과 독립적인 값으로 생성된다.
> 참조 타입은 동작을 정의하는 용도로 사용한다. 할당 시, 메모리 주소가 복사되어 원본과 같은 곳을 바라본다.

- 이렇게 다른 두 가지 방식은 개발자로 하여금 혼동만 줄 것 같은데, 그럼에도 두 개로 나눈 이유가 뭘까?
```
타입을 용도에 맞게 사용하면, 값과 참조 방식의 장점만 취할 수 있다.
```

- 예제1의 상반된 결과가 나온 이유를 다시 보자. 
    1. 값 타입은 할당 시, 모든 속성(데이터)가 복사되므로 비용이 높다. 반면 참조 타입은 복사 비용이 거의 없다. 참조만 새로 걸어주면 되기 때문이다.
    2. 참조는 할당이 쉬운 대신 메모리 관리구조가 복잡해져 메모리 관리 비용이 올라간다. 반면 값 타입은 메모리 관리가 거의 필요없을 정도로 단순한 구조를 보인다.

- 그렇다면 메모리 메커니즘을 보자.

### 메모리 메커니즘
#### 값 타입
- 값 타입은 매우 단순하다. 해당 코드 블록(범위)안에서만 사용되고, 그 범위를 벗어나면 사용할 일이 없다.
- 예제2
```cs
// 첫 번째 블록
int a = 100;
int b = 200;

var sum = Sum(a, b);

Console.WriteLine(sum);

private int Sum(int input1, int input2)
{
    // 두 번째 블록
    return input1 + input2;
}
```
- 예제2의 코드 블록은 두 개다. 첫 번째 블록는 변수 a, b 가 선언되는 컨텍스트이고, 두 번째는 Sum 메서드 내부이다. 
두 번째 블록은 첫 번째 블록 위에 존재하므로 스택으로 표현하기에 제격이다. 
```
                 두 번째 블록
첫 번째 블록   ->   첫 번째 블록   -> 첫 번째 블록
```

- 여기서 주목할 것은 a, b와 input1, input2는 전혀 상관이 없다는 사실이다. Sum을 호출하면 말그대로 값 자체(100, 200)를 전달하고, Sum() 메서드가 결과를 반환하면 input1, input2는 자동으로 스택에서 제거된다.
> input1, input2 는 값 타입이므로 범위를 벗어날 때 바로 제거된다.

- 정리
    - 값 타입은 스택에 저장되고, 코드 블록을 벗어나면 자동으로 제거된다.
    - (장점) 별도로 메모리를 관리할 필요가 없다.
    - (단점) 매번 데이터를 모두 복사해야 한다. (값 타입 자체의 규모가 커질수록 비효율적)

#### 참조 타입
- 값 타입과 달리, 참조 타입은 데이터 할당 시 메모리 주소의 복사만 일어난다고 했다. 쉽게 말하면 원본이 저장된 곳을 가르키는 링크가 생기는 것이다.
- 예제3
```cs
{
    // 코드 블록 시작

    // 모든 참조 타입은 System.Object로부터 파생된다.
    object a = 10;
    object b = 20;
    
    ...
    // 코드 블록 끝
}
```
- [사진1]

> 참조 타입은 스택과 힙 모두에 저장된다. 힙에는 데이터 원본이 저장되며, 스택에는 힙 주소가 저장된다.
- 예제3의 코드 블록이 끝나면 스택은 날라가지만, 힙에는 여전히 데이터가 남아 있게된다.

- [사진2]

```
Q. 참조 형식이 가비지 컬렉터로 관리되는 이유?
 변수에 참조 데이터를 할당 시, 해당 변수(스택)는 참조 데이터가 보관된 힙의 메모리 주소를 할당 받는다.
 이에 따라 (실제 데이터가 있는) 힙과 (데이터 주소를 받은) 스택 사이 연결(참조) 관계가 생기는데, 해당 참조 관계는 여러 개가 생길 수 있다.
 이에 따라 참조 횟수를 관리해야만 힙 데이터의 사용 여부를 알 수 있으므로 별도의 가비지 컬렉터에서 참조 횟수를 추적하여 0이 될 때, 힙 원본 데이터를 제거할 수 있게 된다.
```

# 2. 값 타입과 참조 타입을 구분하라
- '1. 값, 참조 형식 (메모리 메커니즘)'에서 값, 참조 타입의 메모리 특성과 이에 따른 장단점을 공부했다. 이제 코드 작성 관점에서 데이터 타입을 값과 참조 중 어떤 것으로 선택해야 하는지 기준을 세워보자. 



